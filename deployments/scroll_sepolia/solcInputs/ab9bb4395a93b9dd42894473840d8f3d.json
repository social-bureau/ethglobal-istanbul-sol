{
  "language": "Solidity",
  "sources": {
    "contracts/core/Prontera.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IProntera.sol\";\n\n/**\n * @title IProntera: key keeper for chatting\n * @author Roongroj\n * @notice version 1.0\n */\ncontract Prontera is IProntera {\n\n    string private version = '1.0.0';\n\n    /// @notice Mapping of user to their initialization object\n    mapping(address => UserInitialization) public userInitializations;\n\n    /// @notice A shared secret between two users, encrypted by the public key of first user\n    mapping(address => mapping(address => bytes)) public chatInitializations;\n\n    constructor(){}\n\n    /**\n     * @notice check if user is already initialized or not\n     * @param user address to query\n     * @return initialized as a boolean\n     */\n    function isUserInitialized(address user) public view returns (bool){\n        return !(userInitializations[user].encryptedUserSecret.length == 0 &&\n            userInitializations[user].publicKeyX == bytes32(0));\n    }\n\n    /**\n     * @notice check if initializer and user is already initialized or not\n     * @param initializer address to query\n     * @param peer address to query\n     * @return initialized as a boolean\n     */\n    function isChatInitialized(address initializer, address peer) public view returns (bool){\n        return !(chatInitializations[initializer][peer].length == 0 && chatInitializations[peer][initializer].length == 0);\n    }\n\n    /**\n     * @notice initialize user, some kind of registering process, which allows two things:\n     * - user will be able to generate their own key on later logins, by retrieving the encrypted key-gen input and decrypt with their MetaMask\n     * - other users will be able to encrypt messages using this users public key\n     * @param encryptedUserSecret user secret to generate key-pair for the chatting application. it is encrypted by the MetaMask public key\n     * @param publicKeyPrefix prefix of the compressed key stored as a boolean (0x02: true, 0x03: false)\n     * @param publicKeyX 32-byte X-coordinate of the compressed key\n     */\n    function initializeUser(\n        bytes calldata encryptedUserSecret,\n        bool publicKeyPrefix,\n        bytes32 publicKeyX\n    ) external {\n        if (isUserInitialized(msg.sender)) {\n            revert UserAlreadyInitialized(msg.sender);\n        }\n        userInitializations[msg.sender] = UserInitialization(encryptedUserSecret, publicKeyPrefix, publicKeyX);\n        emit UserInitialized(msg.sender, userInitializations[msg.sender]);\n    }\n\n    /**\n     * @notice initializes a chatting session between two users: msg.sender and a given peer.\n     * A symmetric key is encrypted with both public keys once and stored for each\n     * @dev Both users must be initialized\n     * @param callerEncryptedChatSecret Symmetric key, encrypted by the msg.sender's public key\n     * @param peerEncryptedChatSecret Symmetric key, encrypted by the peer's public key\n     * @param peer address of the peer\n     */\n    function initializeChat(\n        bytes calldata callerEncryptedChatSecret,\n        bytes calldata peerEncryptedChatSecret,\n        address peer\n    ) external {\n        if (!isUserInitialized(msg.sender)) {\n            revert UserIsNotInitialized(msg.sender);\n        }\n        if (!isUserInitialized(peer)) {\n            revert PeerIsNotInitialized(peer);\n        }\n        chatInitializations[msg.sender][peer] = callerEncryptedChatSecret;\n        chatInitializations[peer][msg.sender] = peerEncryptedChatSecret;\n        emit ChatInitialized(msg.sender, peer, callerEncryptedChatSecret, peerEncryptedChatSecret);\n    }\n\n    /**\n     * @notice get user initialized information.\n     * @param user address to query\n     * @return data as UserInitialization struct\n     */\n    function getUserInitialization(address user) external view returns (UserInitialization memory){\n        return userInitializations[user];\n    }\n\n    /**\n     * @notice get chat initialized information, shared secret between two users, encrypted by the public key of initializer user\n     * @param firstUser address to query\n     * @param secondUser address to query\n     * @return get a symmetric key map by firstUser => secondUser\n     */\n    function getChatInitialization(address firstUser, address secondUser) external view returns (bytes memory){\n        return chatInitializations[firstUser][secondUser];\n    }\n\n    /**\n     * @notice get contract version\n     * @return string of version\n     */\n    function getVersion() external view returns (string memory){\n        return version;\n    }\n}\n"
    },
    "contracts/interfaces/IProntera.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IProntera: key keeper for chatting\n * @author Roongroj\n * @notice version 1.0\n */\ninterface IProntera {\n\n    error UserAlreadyInitialized(address user);\n    error UserIsNotInitialized(address user);\n    error PeerIsNotInitialized(address peer);\n    error ChatIsNotInitialized(address user, address peer);\n\n    event UserInitialized(address indexed user, UserInitialization init);\n    event ChatInitialized(address indexed initializer, address indexed peer, bytes callerEncryptedChatSecret, bytes peerEncryptedChatSecret);\n\n    struct UserInitialization {\n        bytes encryptedUserSecret;\n        bool publicKeyPrefix;\n        bytes32 publicKeyX;\n    }\n\n    /**\n     * @notice check if user is already initialized or not\n     * @param user address to query\n     * @return initialized as a boolean\n     */\n    function isUserInitialized(address user) external view returns (bool);\n\n    /**\n     * @notice check if initializer and user is already initialized or not\n     * @param initializer address to query\n     * @param peer address to query\n     * @return initialized as a boolean\n     */\n    function isChatInitialized(address initializer, address peer) external view returns (bool);\n\n    /**\n     * @notice initialize user, some kind of registering process, which allows two things:\n     * - user will be able to generate their own key on later logins, by retrieving the encrypted key-gen input and decrypt with their MetaMask\n     * - other users will be able to encrypt messages using this users public key\n     * @param encryptedUserSecret user secret to generate key-pair for the chatting application. it is encrypted by the MetaMask public key\n     * @param publicKeyPrefix prefix of the compressed key stored as a boolean (0x02: true, 0x03: false)\n     * @param publicKeyX 32-byte X-coordinate of the compressed key\n     */\n    function initializeUser(\n        bytes calldata encryptedUserSecret,\n        bool publicKeyPrefix,\n        bytes32 publicKeyX\n    ) external;\n\n    /**\n     * @notice initializes a chatting session between two users: msg.sender and a given peer.\n     * A symmetric key is encrypted with both public keys once and stored for each\n     * @dev Both users must be initialized\n     * @param callerEncryptedChatSecret Symmetric key, encrypted by the msg.sender's public key\n     * @param peerEncryptedChatSecret Symmetric key, encrypted by the peer's public key\n     * @param peer address of the peer\n     */\n    function initializeChat(\n        bytes calldata callerEncryptedChatSecret,\n        bytes calldata peerEncryptedChatSecret,\n        address peer\n    ) external;\n\n    /**\n     * @notice get user initialized information\n     * @param user address to query\n     * @return data as UserInitialization struct\n     */\n    function getUserInitialization(address user) external view returns (UserInitialization memory);\n\n    /**\n     * @notice get chat initialized information, shared secret between two users, encrypted by the public key of initializer user\n     * @param firstUser address to query\n     * @param secondUser address to query\n     * @return get a symmetric key map by firstUser => secondUser\n     */\n    function getChatInitialization(address firstUser, address secondUser) external view returns (bytes memory);\n\n    /**\n     * @notice get contract version\n     * @return string of version\n     */\n    function getVersion() external view returns (string memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}